# Content Management Options for UrantiaBookPod

_Last updated: 2025-06-20_

## 1. Background & Pain-Points

The current site assembles UI text, episode metadata, and media URLs from a collection of hand-maintained JSON files.  This worked for the initial migration but is now showing clear weaknesses:

* **Scattered Truth-Sources** – logic in `episodeUtils.ts`, stale fields in `episodes.json`, and translation JSONs all compete.
* **High Bug-Surface** – every manual change risks breaking paths or clashing with TypeScript models.
* **Poor Editorial UX** – non-technical contributors must edit Git-tracked JSON by hand.
* **Translation Overhead** – synchronising EN⇆ES keys across many files is error-prone.

A lightweight CMS layer would consolidate content, enforce schemas, and offer a friendlier workflow while staying true to the project's _static-first, host-agnostic_ philosophy.

---

## 2. CMS Requirements

| Requirement | Notes |
|-------------|-------|
| **Static build-time delivery** | Pages should still be generated by Vite/React without a runtime DB. |
| **Git versioned** | All content changes must travel through PRs for review and localisation. |
| **Multi-language** | At minimum EN & ES, scalable to more. |
| **Episode & series schema** | `title`, `description`, `audioUrl`, `pdfUrl`, `imageUrl`, `summaryKey`, etc. |
| **Media URL helpers** | Continue deriving R2 URLs from IDs, not storing full paths. |
| **Low dev-ops overhead** | No new servers to patch or pay for. |

---

## 3. Candidate Approaches

### 3.1 Pure JSON (+ Zod validation)
* **What** – Keep JSON files but refactor into tidy per-language folders (`/content/en/series/*.json`). Use a shared Zod schema checked in CI.
* **Pros**  
  • Zero new dependencies  
  • Fastest build-time look-ups  
  • Git remains single source-of-truth
* **Cons**  
  • Non-tech editors need Git access  
  • No rich editing UI  
  • Still manual merge conflict resolution

### 3.2 Git-based Headless CMS (Decap CMS / Netlify CMS)
* **What** – Adds a React/SPA admin panel that commits to the repo via GitHub API.
* **Pros**  
  • Friendly web UI, markdown/JSON widgets  
  • Lives entirely in the existing repo (static admin)  
  • Works on any host (Vercel, etc.)
* **Cons**  
  • Requires GitHub OAuth app  
  • Build may trigger on every editorial save  
  • Custom widget work for complex episode fields

### 3.3 Filesystem CMS with Structured Content (Contentlayer, Dato "Content SDK", Tina Cloud)
* **What** – Author content in Markdown/YAML; tooling generates typed objects at build-time.
* **Pros**  
  • Generates TypeScript types automatically  
  • Hot-reload in local dev  
  • Good localisation patterns (folder-based)
* **Cons**  
  • Additional dev dependencies  
  • Still Git-centric – editors need PR workflow or a hosted GUI (Tina Cloud $)

### 3.4 Hosted Headless CMS (Sanity, Strapi, Storyblok)
* **What** – Content stored in an external DB, queried at build time via API.
* **Pros**  
  • Excellent editorial UI, roles, comments  
  • Real-time previews  
  • Image pipeline, i18n plugins
* **Cons**  
  • New billing surface / vendor lock-in  
  • Requires secret keys & serverless caching  
  • Complicates local-offline development

### 3.5 Edge Database (Supabase, Postgres on Vercel)
* **What** – Full SQL with REST/GQL endpoints.
* **Pros**  
  • Powerful relational queries (e.g., playlist builder)  
  • Row-level translations  
  • Could power future dynamic features (search, feedback)
* **Cons**  
  • Overkill for mainly static podcast catalogue  
  • Adds runtime dependency & cold-start considerations  
  • Data migration & backups become critical

---

## 4. Recommendation

**Phase 1 – Git-based Headless CMS (Decap CMS)**

1. **Maintain static JSON/Markdown** in repo to keep zero-runtime guarantee.
2. **Add `/admin`** route powered by Decap CMS configured for GitHub.
3. Define collections: `series`, `episodes`, `translations` with proper widgets.
4. **Strip `audioUrl` & `pdfUrl` fields** – derive at build from ID helpers to avoid drift.
5. **Type safety** – run a Zod validator in CI to ensure commits match schema.
6. **Localisation** – store parallel docs per language; editors toggle locale in UI.

Pros: immediate editorial benefit, no infra cost, minimal code churn. If needs grow, migrate content to a hosted CMS later without breaking consumer code by keeping the same generated JSON shape.

---

## 5. Migration Plan (High Level)

1. **Schema Design** – draft `Episode`, `Series`, and `TranslationBlock` Zod schemas.
2. **Automated Transform** – write a script to convert current JSONs into the new structure.
3. **Integrate Decap CMS** – add `admin` folder, `config.yml`, and GitHub auth.
4. **Refactor Build Step** – import generated JSON from `/content` instead of `src/data/json`.
5. **CI Gate** – validate JSON on PR, ensure no hard-coded URLs slip in.
6. **Docs & On-boarding** – update README, record short Loom for editors.

---

## 6. Future Enhancements

* **Rich Text Markdown** for episode show notes.
* **Guest Author Profiles** stored as a separate collection.
* **Preview Links** using Vercel Preview deployments for content editors.
* **Incremental Adoption** – start with EN, then enable ES, then additional locales.

---

## 7. Conclusion

Moving to a Git-based headless CMS (Decap CMS) strikes the best balance between **robustness**, **cost-effectiveness**, and **ease of adoption** for the current scale of UrantiaBookPod.  It keeps the site 100 % static, simplifies editor workflows, and eliminates the class of bugs seen during the R2 migration by enforcing a single, validated source of truth. 